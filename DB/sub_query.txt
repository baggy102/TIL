SUB QUERY

서브쿼리는 쓰이는 위치에 따라 3가지 종류로 나뉜다.

- SELECT 절에 사용하는 SCALAR SUBQUERY

- FROM 절에 사용하는 INLINE VIEW

- WHERE 절에 사용하는 중첩 서브쿼리

WHERE 중첩 서브쿼리

단일 행 서브쿼리

SELECT * FROM HR/EMPLOYEES A
	WHERE A.DEPARTMENT_ID = (SELECT B.DEPARMENT_ID
					FROM HR.DEPARTMENTS B
					WHERE B.LOCATION_ID =1800);

-> LOCATION_ID 가 1800인 부서의 아이디를 SELECT 한 다음
해당 부서 ID를 가지는 사원을 최종적으로 뽑아내는 query


만약 LOCATION_ID 가 1800인 부서가 하나가 아니라 여러개인 경우에는?

SELECT * FROM HR/EMPLOYEES A
	WHERE A.DEPARTMENT_ID IN (SELECT B.DEPARMENT_ID
					FROM HR.DEPARTMENTS B
					WHERE B.LOCATION_ID =1800);

위의 서브쿼리로 작성된 query 문을 JOIN으로 풀어 쓰게 되면

SELECT *
	FROM HR.EMPLOYEES A.
	     HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
	AND B.LOCATION_ID = 1700;

일반적으로 이렇게 서브 쿼리를 사용해도 성능에는 크게 상관이 없지만
반드시 사용하면 안되는 경우가 존재한다.


HR.EMPLOYEES 중 급여가 최고인 사람과 최저인 사람

SELECT A.EMPLOTEE_ID,
	A.FIRST_NAME,
	A.LAST_NAME,
	A.SALARY
 FROM HR.EMPLOYEES A
	WHERE A.SALARY = (SELECT MIN(SALARY) FROM HR.EMPLOYEES)
	OR A.SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES);

-> 위 경우 서브쿼리의 테이블이 메인 쿼리의 테이블과 일치한다.
이 경우 하나의 query 안에서 한 테이블에 3번의 access가 이루어진다.

SELECT B.EMPLOTEE_ID,
	B.FIRST_NAME,
	B.LAST_NAME,
	B.SALARY
 FROM (
		SELECT A.EMPLOTEE_ID,
			A.FIRST_NAME,
			A.LAST_NAME,
			A.SALARY
			ROW_NUMBER() OVER(ORDER BY SALARY) MINSAL,
			ROW_NUMBER() OVER(ORDER BY SALARY DESC) MAXSAL
 		FROM HR.EMPLOYEES A;
	) B
 WHERE B.MINSAL = 1 OR B.MAXSAL = 1;


스칼라 서브쿼리

하나의 레코드 당 하나의 레코드 당 하나의 값을 리턴하는 서브쿼리
보통은 SELECT 절에 많이 쓰이나 그 이외에도
컬럼 값이 올 수 있는 모든 자리에 쓰일 수 있다.

SELECT FIRST_NAME,
	LAST_NAME,
	SALARY,
	DEPARTMENT_ID
 FROM EMPLOYEES
 WHERE SALARY > 5000;

DEPARTMENT_ID 값만 가지고 어떤 이 사람이 어떤 부서인지 짐작하기 힘들기 때문에
NAME을 가져오고 싶은데, EMPLOYEES TABLE에 NAME이라는 컬럼이 존재하지 않는 경우

이 때 스칼라 서브쿼리를 통해 DEPARTMENT TABLE에서 DEPARTMENT_NAME 컬럼을 가져올 수 있다.

SELECT FIRST_NAME,
	LAST_NAME,
	SALARY,
	(SELECT B.DEPARTMENT_NAME 
		FROM DEPARTMENT B WHERE B.DEPARTMENT_ID = A.DEPARTMENT_ID) AS DEPT_NM
 FROM EMPLOYEES A
WHERE SALARY > 5000;

동작
-> 스칼라 서브쿼리가 나중에 ACCESS하게 된 테이블
상수값으로 메인 쿼리에 있는 컬럼이 쓰였기 때문에

메인 TABLE A가 DRIVING TABLE,
DEPARTMENT TABLE이 INNER TABLE 이 된다.

즉, EMPLOYEES TABLE을 풀 스캔한 뒤 나온 DEPARTMENT_ID를 가지고
DEPARTMENT TABLE의 PK 인덱스를 스캔, TABLE ACCESS 하고 값을 가져온다.


INLINE VIEW

FROM 절에 쓰이는 SUB QUERY

INLINE VIEW OBJECT를 생성하지 않고 SQL 내에 직접 기술 해 쓰이는 일회성 VIEW

부서별 급여의 평균값

SELECT A.DEPARTMENT_NAME,
	B.AVG_SAL
 FROM DEPARTMENTS 
	(SELECT DEPARTMENT_ID,
		ROUND(AVG(SALARY),2) AVG_SAL
	 FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID) B;
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID;