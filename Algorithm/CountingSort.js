// 계수 정렬

// 작은 숫자에서 복잡도가 O(n+k)인 알고리즘으로써
// 정렬할 수들의 최대값에 영향을 받는 알고리즘이다.

// 모든 숫자의 개수를 센 후, 누적 합을 구하고, 다시 숫자를 넣어준다.

// [3,4,0,1,2,4,2,4], [개수를 저장할 공간], [결과]
// 개수를 저장할 공간을 정렬할 제일 큰 수의 갯수만큼 0으로 만들어준다.

// [3,4,0,1,2,4,2,4], [0,0,0,0,0], [결과]
// 처음부터 개수를 세어 저장한다. 0은 1개, 1은 1개, 2는 2개, 3은 1개, 4는 3개.

// [3,4,0,1,2,4,2,4], [1,1,2,1,3], [결과]
// 개수를 저장한 것을 누적합으로 바꿔준다. -> 순서대로 1,2,4,5,8

// [3,4,0,1,2,4,2,4], [1,2,4,5,8], [결과]
// 누적합을 바탕으로 숫자를 결과에 넣어준다. 0은 1에, 1은 2에, 2는 3~4에 3은 5에, 4는 6~8에 넣어준다.

// [3,4,0,1,2,4,2,4], [1,2,4,5,8], [0,1,2,2,3,4,4,4]

// 누적합이 숫자들의 인덱스 역할
// 1,3,4,7이 있으면 1은 0~1 사이에, 2는 1~3 사이에, 3은 3~4 사이에, 4는 4~7 사이에 넣으면 된다.

let countingSort = function (array, k) {
  let count = [],
    result = [];
  for (let i = 0; i <= k; i++) {
    // 모든 숫자의 개수를 일단 0으로 초기화 함.
    count[i] = 0;
  }
  console.log(count, result, array.length);
  for (let j = 0; j < array.length; j++) {
    // 숫자의 개수를 세어 저장한다.
    count[array[j]] += 1;
  }
  console.log(count, result, k);
  for (i = 0; i < k; i++) {
    // 누적합의 합을 구함.
    count[i + 1] += count[i];
  }
  console.log(count, result);
  for (j = 0; j < array.length; j++) {
    // 누적합이 가리키는 인덱스를 바탕으로 결과에 숫자를 넣음.
    console.log(array[j], count[array[j]] - 1);
    result[count[array[j]] - 1] = array[j];
    count[array[j]] -= 1;
  }
  console.log(count, result);
  return result;
};

// 배열에 큰 수가 들어갈 수록 메모리를 많이 잡아먹기 때문에 좋지않다.

countingSort([3, 4, 0, 1, 2, 4, 2, 4], 4);
console.log(countingSort([3, 4, 0, 1, 2, 4, 2, 4], 4));
