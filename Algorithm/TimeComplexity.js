// 시간 복잡도
// 시간 복잡도는 알고리즘을 수행하는 데 평균적으로, 또는 얼마만큼의 시간이 걸리는 지 보여준다.
// 반대의 개념으로 공간의 복잡도도 있는데, 이는 알고리즘이 얼마만큼의 메모리를 잡아먹는지 보여준다.

// 복잡도는 주로 빅오 표기법을 사용해 나타낸다.
// 최악의 경우 걸리는 시간을 표기하는 방법으로

// 빅오의 순서는 다음과 같다.

// O(1), O(logN), O(N), O(N^2), O(N^3), ..., O(2^N), O(N!)

// 모두 어떤 동작을 수행할 때 ㅊ최악의 경우 걸리는 시간을 의미한다. 왼쪽으로 갈수록 좋은 알고리즘이고,
// 오른쪽으로 갈수록 안 좋은 알고리즘이다.
// 보통 NlogN까지를 괜찮다고 생각하고, N^@부터는 안 좋다고 생각하면된다.
// 최악의 경우를 뜻하기 때문에 최선의 경우는 O(1)도 나올 수 있습니다. 즉 O(N^2)는 O(1)부터
// O(NlogN)까지를 모두 포함하고 있습니다.

// 삽입정렬은 O(N^2)이다. (ON^2)가 안좋다고 했지만 사용하는 이유는 알고리즘 자체가 간단하기 때문
// 또 30개 이하의 숫자의 경우에는 괜찮은 성능을 보인다.

// 간단하게 빅오의 차이가 성능을 얼마나 좌우하는지 보자면

//      O(N),   O(NlogN),   O(N^2), O(2^N)
// N=1      1,         0,        1,     2
// N=10    10,        23,      100,   1024
// N=100  100,       460,    10000,  0이 30개

// 하나당 0.01초가 걸린다고 생각해도 만약 100개를 정렬하는 경우, O(NlogN)은 4.6초로 괜찮다고
// 생각할 수 있지만, O(N^2)는 100초가 걸린다.

// 세타 표기법
// 평균의 경우를 나타낸다.
// 최악의 경우가 잘 일어나지 않는 알고리즘의 경우 최악의 경우를 제외하고 세타 표기법으로 파악
// 빅오 표기법과 유사하지만 O만 Θ로 바꾸면 된다. 역시 Θ(N^2) 부터는 안좋다고 여겨진다.
// 평균적인 경우이기 때문에 최악의 경우, 최선의 경우 모두 Θ(N^2)이다.
